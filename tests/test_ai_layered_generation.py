"""Tests for layered AI generation methods.

Tests for:
- generate_location_with_context (Layer 3 - location without NPCs)
- generate_npcs_for_location (Layer 4 - NPCs for a location)
"""

import json
import pytest
from unittest.mock import Mock, patch

from cli_rpg.ai_config import AIConfig
from cli_rpg.ai_service import AIService, AIGenerationError
from cli_rpg.models.world_context import WorldContext
from cli_rpg.models.region_context import RegionContext


@pytest.fixture
def basic_config(tmp_path):
    """Create a basic AIConfig for testing with isolated cache file."""
    return AIConfig(
        api_key="test-key-123",
        model="gpt-3.5-turbo",
        temperature=0.7,
        max_tokens=500,
        max_retries=3,
        retry_delay=0.1,
        cache_file=str(tmp_path / "test_cache.json"),
    )


@pytest.fixture
def world_context():
    """Create a WorldContext for testing."""
    return WorldContext(
        theme="fantasy",
        theme_essence="A dark and mysterious fantasy realm with ancient magic",
        naming_style="Old English with Celtic influence",
        tone="grim but hopeful",
    )


@pytest.fixture
def region_context():
    """Create a RegionContext for testing."""
    return RegionContext(
        name="The Withered Woods",
        theme="twisted forest with corrupted trees",
        danger_level="dangerous",
        landmarks=["The Dead Oak", "Witch's Hollow"],
        coordinates=(5, 3),
    )


# --- Tests for generate_location_with_context ---
# Tests Step 1 in the plan: Add generate_location_with_context() to AIService


class TestGenerateLocationWithContext:
    """Test generate_location_with_context returns location without NPCs."""

    @patch("cli_rpg.ai_service.OpenAI")
    def test_returns_valid_structure(
        self, mock_openai_class, basic_config, world_context, region_context
    ):
        """Test generate_location_with_context returns location without NPCs."""
        mock_client = Mock()
        mock_openai_class.return_value = mock_client

        # Response without NPCs (as expected from minimal prompt)
        valid_response = {
            "name": "Corrupted Clearing",
            "description": "A twisted clearing where no birds sing.",
            "category": "forest",
        }

        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = json.dumps(valid_response)
        mock_client.chat.completions.create.return_value = mock_response

        service = AIService(basic_config)
        result = service.generate_location_with_context(
            world_context=world_context,
            region_context=region_context,
            source_location="Village Gate",
            direction="north",
        )

        # Verify structure - should have location fields but no NPCs or connections
        # (connections are handled by WFC, not AI)
        assert "name" in result
        assert "description" in result
        assert "connections" not in result  # WFC handles terrain structure
        assert "category" in result
        # NPCs should be empty list (not generated by this method)
        assert result.get("npcs") == []
        assert result["name"] == "Corrupted Clearing"

    @patch("cli_rpg.ai_service.OpenAI")
    def test_uses_minimal_prompt_template(
        self, mock_openai_class, basic_config, world_context, region_context
    ):
        """Test that minimal prompt template is used with context variables."""
        mock_client = Mock()
        mock_openai_class.return_value = mock_client

        valid_response = {
            "name": "Dark Path",
            "description": "A narrow path through thorns.",
            "category": "wilderness",
        }

        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = json.dumps(valid_response)
        mock_client.chat.completions.create.return_value = mock_response

        service = AIService(basic_config)
        service.generate_location_with_context(
            world_context=world_context,
            region_context=region_context,
            source_location="Old Mill",
            direction="east",
            terrain_type="wilderness"
        )

        # Verify prompt was called with context information
        call_args = mock_client.chat.completions.create.call_args
        prompt = call_args[1]["messages"][0]["content"]

        # Check that context variables are included in prompt
        # Note: source_location and direction are no longer in prompt (deprecated)
        assert world_context.theme_essence in prompt
        assert region_context.name in prompt
        assert region_context.theme in prompt
        assert "wilderness" in prompt  # terrain_type

    @patch("cli_rpg.ai_service.OpenAI")
    def test_validates_name_length(
        self, mock_openai_class, basic_config, world_context, region_context
    ):
        """Test validation rejects names that are too short or too long."""
        mock_client = Mock()
        mock_openai_class.return_value = mock_client

        # Name too short
        invalid_response = {
            "name": "X",  # Too short (min 2)
            "description": "A valid description for testing.",
            "connections": {},
            "category": "forest",
        }

        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = json.dumps(invalid_response)
        mock_client.chat.completions.create.return_value = mock_response

        service = AIService(basic_config)

        with pytest.raises(AIGenerationError, match="name.*short"):
            service.generate_location_with_context(
                world_context=world_context,
                region_context=region_context,
            )

    @patch("cli_rpg.ai_service.OpenAI")
    def test_handles_optional_source_direction(
        self, mock_openai_class, basic_config, world_context, region_context
    ):
        """Test works without source_location and direction (for starting location)."""
        mock_client = Mock()
        mock_openai_class.return_value = mock_client

        valid_response = {
            "name": "Starting Glade",
            "description": "A peaceful glade where your journey begins.",
            "connections": {"north": "Dark Forest"},
            "category": "wilderness",
        }

        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = json.dumps(valid_response)
        mock_client.chat.completions.create.return_value = mock_response

        service = AIService(basic_config)

        # Call without source_location and direction
        result = service.generate_location_with_context(
            world_context=world_context,
            region_context=region_context,
        )

        assert result["name"] == "Starting Glade"


# --- Tests for generate_npcs_for_location ---
# Tests Step 2 in the plan: Add generate_npcs_for_location() to AIService


class TestGenerateNpcsForLocation:
    """Test generate_npcs_for_location returns list of valid NPCs."""

    @patch("cli_rpg.ai_service.OpenAI")
    def test_returns_valid_npcs(self, mock_openai_class, basic_config, world_context):
        """Test generate_npcs_for_location returns list of valid NPCs."""
        mock_client = Mock()
        mock_openai_class.return_value = mock_client

        valid_response = {
            "npcs": [
                {
                    "name": "Old Hermit",
                    "description": "A weathered man with knowing eyes.",
                    "dialogue": "The forest remembers all who enter...",
                    "role": "villager",
                },
                {
                    "name": "Wandering Merchant",
                    "description": "A trader with mysterious wares.",
                    "dialogue": "Care to see what I have?",
                    "role": "merchant",
                },
            ]
        }

        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = json.dumps(valid_response)
        mock_client.chat.completions.create.return_value = mock_response

        service = AIService(basic_config)
        result = service.generate_npcs_for_location(
            world_context=world_context,
            location_name="Corrupted Clearing",
            location_description="A twisted clearing where no birds sing.",
            location_category="forest",
        )

        assert isinstance(result, list)
        assert len(result) == 2
        assert result[0]["name"] == "Old Hermit"
        assert result[0]["role"] == "villager"
        assert result[1]["name"] == "Wandering Merchant"
        assert result[1]["role"] == "merchant"

    @patch("cli_rpg.ai_service.OpenAI")
    def test_handles_empty_response(
        self, mock_openai_class, basic_config, world_context
    ):
        """Test empty NPC list is valid."""
        mock_client = Mock()
        mock_openai_class.return_value = mock_client

        valid_response = {"npcs": []}

        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = json.dumps(valid_response)
        mock_client.chat.completions.create.return_value = mock_response

        service = AIService(basic_config)
        result = service.generate_npcs_for_location(
            world_context=world_context,
            location_name="Empty Cave",
            location_description="A dark cave with no inhabitants.",
        )

        assert isinstance(result, list)
        assert len(result) == 0

    @patch("cli_rpg.ai_service.OpenAI")
    def test_validates_npc_fields(
        self, mock_openai_class, basic_config, world_context
    ):
        """Test NPC field validation filters invalid NPCs."""
        mock_client = Mock()
        mock_openai_class.return_value = mock_client

        # Mix of valid and invalid NPCs
        response_with_invalid = {
            "npcs": [
                {
                    "name": "Valid NPC",
                    "description": "A normal villager.",
                    "dialogue": "Hello there!",
                    "role": "villager",
                },
                {
                    "name": "X",  # Invalid: name too short
                    "description": "Too short name.",
                    "dialogue": "...",
                    "role": "villager",
                },
                {
                    "name": "Missing Description",
                    "description": "",  # Invalid: empty description
                    "dialogue": "Hello",
                    "role": "villager",
                },
            ]
        }

        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = json.dumps(response_with_invalid)
        mock_client.chat.completions.create.return_value = mock_response

        service = AIService(basic_config)
        result = service.generate_npcs_for_location(
            world_context=world_context,
            location_name="Village",
            location_description="A small village.",
        )

        # Only the valid NPC should be returned
        assert len(result) == 1
        assert result[0]["name"] == "Valid NPC"

    @patch("cli_rpg.ai_service.OpenAI")
    def test_uses_minimal_npc_prompt(
        self, mock_openai_class, basic_config, world_context
    ):
        """Test that NPC prompt includes world context and location info."""
        mock_client = Mock()
        mock_openai_class.return_value = mock_client

        valid_response = {
            "npcs": [
                {
                    "name": "Guard",
                    "description": "A vigilant guard.",
                    "dialogue": "Halt!",
                    "role": "villager",
                }
            ]
        }

        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = json.dumps(valid_response)
        mock_client.chat.completions.create.return_value = mock_response

        service = AIService(basic_config)
        service.generate_npcs_for_location(
            world_context=world_context,
            location_name="Town Gate",
            location_description="The main entrance to the town.",
            location_category="town",
        )

        # Verify prompt contains context
        call_args = mock_client.chat.completions.create.call_args
        prompt = call_args[1]["messages"][0]["content"]

        assert world_context.theme_essence in prompt
        assert world_context.naming_style in prompt
        assert "Town Gate" in prompt
        assert "main entrance" in prompt
        assert "town" in prompt

    @patch("cli_rpg.ai_service.OpenAI")
    def test_handles_missing_npcs_key(
        self, mock_openai_class, basic_config, world_context
    ):
        """Test handles response without 'npcs' key gracefully."""
        mock_client = Mock()
        mock_openai_class.return_value = mock_client

        # Response missing 'npcs' key
        invalid_response = {
            "characters": []  # Wrong key
        }

        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = json.dumps(invalid_response)
        mock_client.chat.completions.create.return_value = mock_response

        service = AIService(basic_config)
        result = service.generate_npcs_for_location(
            world_context=world_context,
            location_name="Empty Place",
            location_description="A place with no one.",
        )

        # Should return empty list when 'npcs' key is missing
        assert isinstance(result, list)
        assert len(result) == 0

    @patch("cli_rpg.ai_service.OpenAI")
    def test_defaults_role_to_villager(
        self, mock_openai_class, basic_config, world_context
    ):
        """Test NPCs without role default to 'villager'."""
        mock_client = Mock()
        mock_openai_class.return_value = mock_client

        response_without_role = {
            "npcs": [
                {
                    "name": "Unnamed Peasant",
                    "description": "A simple farmer.",
                    "dialogue": "Good day!",
                    # No role specified
                }
            ]
        }

        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = json.dumps(response_without_role)
        mock_client.chat.completions.create.return_value = mock_response

        service = AIService(basic_config)
        result = service.generate_npcs_for_location(
            world_context=world_context,
            location_name="Farm",
            location_description="A small farm.",
        )

        assert len(result) == 1
        assert result[0]["role"] == "villager"
